#ifndef MIDIMAPPINGMANAGER_H
#define MIDIMAPPINGMANAGER_H

#include <QObject>
#include <QJsonObject>
#include <QQuickItem>
#include <QPointer>
#include <QMap>

#include "MidiManager.h"

// Forward declaration to reduce dependencies
class MainController;


class MidiMappingManager : public QObject
{
    Q_OBJECT

    Q_PROPERTY(bool feedbackEnabled READ getFeedbackEnabled WRITE setFeedbackEnabled NOTIFY feedbackEnabledChanged)

    QJsonObject h2qj(const QHash<QString, QVector<uint32_t>> &h) const;
    QJsonObject h2qj(const QHash<uint32_t, QVector<QString>> &h) const;

public:

    explicit MidiMappingManager(MainController* controller);

    // ------------------- Persistence --------------------

    /**
     * @brief getState returns the settings of this manager to persist them
     * @return the settings as a QJsonObject
     */
    QJsonObject getState() const;

    /**
     * @brief setState restores the settings from a saved Json object
     * @param state a QJsonObject previously generated by getState()
     */
    void setState(const QJsonObject& state);

signals:
    void feedbackEnabledChanged();

public slots:

    // ------------- interface that is accessable from GUI: -------------

    /**
     * @brief startMappingMidiToControl starts waiting for a GUI control to be touched that will be
     * connected to the next Midi input event
     */
    void startMappingMidiToControl();
    /**
     * @brief startMappingMidiToControlWithFeedback starts waiting for a GUI control to be touched that will be
     * connected to the next Midi input event including MIDI feedback
     */
    void startMappingMidiToControlWithFeedback();
    /**
     * @brief cancelMappingMidiToControl cancels the current GUI item to input event
     * connection attempt (clears the waiting object and midi callback)
     */
    void cancelMappingMidiToControl();

    /**
     * @brief releaseNextControlMapping starts waiting for a GUI control to be touched that will be
     * released from all Midi input events
     */
    void releaseNextControlMapping();
    /**
     * @brief cancelReleaseNextControlMapping cancels releaseNextControl()
     */
    void cancelReleaseNextControlMapping();
    /**
     * @brief releaseNextMidiEventMapping starts waiting for a Midi event that will be
     * released from all GUI controls
     */
    void releaseNextMidiEventMapping();
    /**
     * @brief cancelReleaseNextMidiEventMapping cancels releaseNextMidiEventMapping()
     */
    void cancelReleaseNextMidiEventMapping();

    // ----------------- interface to other classes: -----------------

    /**
     * @brief registerGuiControl register a GUI control so that it can be
     * connected to an external event later
     * @param item the GUI item to register
     * @param controlUid a string describing the control uniquely
     */
    void registerGuiControl(QQuickItem* item, QString controlUid);
    /**
     * @brief unregisterGuiControl unregister a GUI control previously
     * registered with registerGuiControl() because it doesn't any longer exist
     * @param controlUid a string describing the control uniquely
     */
    void unregisterGuiControl(QString controlUid);
    /**
     * @brief getControlFromUid returns a pointer to the control with the given control UID,
     * or a nullptr if the control UID doesn't exist
     * @param controlUid of a GUI item previously registered with registerGuiControl()
     * @return a pointer to a GUI item or nullptr
     */
    QQuickItem* getControlFromUid(QString controlUid) const;

    /**
     * @brief guiControlHasBeenTouched checks if application is waiting for a GUI control
     * to be touched to connect it to an external event
     * @param controllerUid the UID of the control
     */
    void guiControlHasBeenTouched(QString controllerUid);

    /**
     * @brief sendFeedback sends the current value of a control back to the MIDI controller
     * @param uid of the control
     * @param value new value of the control [0...1]
     */
    void sendFeedback(QString uid, double value) const;

    /**
     * @brief clearMapping deletes all mappings
     */
    void clearMapping();

    bool getFeedbackEnabled() const { return m_feedbackEnabled; }

    void setFeedbackEnabled(bool value) { m_feedbackEnabled = value; emit feedbackEnabledChanged(); }

private slots:

    /**
     * @brief mapWaitingControlToMidi connects the waiting GUI item to the
     * specified external input event
     * @param event the external input event to connect to
     */
    void mapWaitingControlToMidi(const MidiEvent& event);

    /**
     * @brief mapControlToMidi connects a control with an input event
     * @param controlUid the uid of the control
     * @param event the input event
     */
    void mapControlToMidi(QString controlUid, const MidiEvent& event);

    /**
     * @brief releaseMapping disconnects a control from all connected input events
     * @param controlUid the uid of the control
     */
    void releaseMapping(QString controlUid);
    /**
     * @brief releaseMapping disconnects a Midi Control from all connected GUI controls
     * @param event the Midi event
     */
    void releaseMapping(const MidiEvent& event);

    /**
     * @brief onExternalEvent handles an incoming input event and checks if controls are connected
     * @param event the incoming input event
     */
    void onExternalEvent(const MidiEvent& event) const;

protected:

    MainController* const m_controller; //!< pointer to MainController instance
    MidiManager* const m_midi; //!< pointer to MidiManager instance

    /**
     * @brief m_waitingForExternalInput contains a GUI control UID that waits to be connected
     * to an external event or nothing
     */
    QString m_controlThatWaitsForMapping;
    /**
     * @brief m_waitingForControl true if application is waiting for a GUI control
     * to connect to a external event
     */
    bool m_isWaitingForControl;

    /**
     * @brief m_connectFeedback is true, when the next MIDI->control mapping should provide feedback
     * back to the MIDI controller
     */
    bool m_connectFeedback;
    /**
     * @brief m_releaseNextControl true if application is waiting for a GUI control
     * to be released from all external events
     */
    bool m_releaseNextControl;

    /**
     * @brief m_feedbackEnabled true if feedback should be send
     */
    bool m_feedbackEnabled;

    /**
     * @brief m_registeredControls map of control UIDs and pointer to the control items
     */
    QMap<QString, QPointer<QQuickItem>>  m_registeredControls;

    /**
     * @brief m_midiToControlMapping the mapping of Midi events to controlUids
     */
    QHash<uint32_t, QVector<QString>> m_midiToControlMappingv2;

    /**
     * @brief m_controlToFeedbackMapping the mapping of controlUids to feedback addresses
     */
    QHash<QString, QVector<uint32_t>> m_controlToFeedbackMappingv2;
};

#endif // MIDIMAPPINGMANAGER_H
